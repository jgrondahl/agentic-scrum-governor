# Phase 3: API Contract & Type Reference

## CLI Command Contract

### Preview Mode
```bash
governor deliver --item <id> [--workdir <path>] [--verbose]
```

**Returns:** Exit code (0-9)
- `0` (Success): Validation passed, artifacts written
- `2` (InvalidRepoLayout): Repo structure invalid
- `3` (ItemNotFound): Item ID not in backlog
- `4` (BacklogParseError): state/backlog.yaml malformed
- `5` (DefinitionOfReadyGateFailed): Preconditions not met
- `8` (ApplyFailed): Unexpected error
- `9` (ValidationFailed): Build or run command failed

### Approval Mode
```bash
governor deliver --item <id> --approve [--workdir <path>] [--verbose]
```

**Semantics:**
1. Runs full preview flow
2. If validation fails: Exits with ValidationFailed (9), NO deployment
3. If validation passes: Deploys and logs decision

---

## Flow Layer: DeliverFlow.Execute()

```csharp
public FlowExitCode Execute(
    string workdir,           // Repository root
    int itemId,               // Backlog item ID
    bool verbose,             // Enable verbose output
    bool approve              // Approval gate flag
)
```

### Processing
1. **Validation:** RepoChecks.ValidateLayout()
2. **Preconditions:** Item exists, status=ready_for_dev, estimate present, epic_id resolvable
3. **Workspace:** IWorkspaceStore.ResetAndCreateWorkspace() → state/workspaces/{appId}/
4. **UseCase:** DeliverUseCase.Process(request)
5. **Decision Logging:** IDecisionStore.LogDecision() if approved

---

## UseCase Layer: DeliverUseCase.Process()

### Input
```csharp
public DeliverResponse Process(DeliverRequest request)
```

### DeliverRequest
```csharp
public class DeliverRequest
{
    public int ItemId { get; set; }                    // From CLI
    public string AppId { get; set; }                  // Resolved from epic_id
    public string BacklogPath { get; set; }            // {workdir}/state/backlog.yaml
    public string RunsDir { get; set; }                // {workdir}/state/runs
    public string Workdir { get; set; }                // Repository root
    public string WorkspaceRoot { get; set; }          // Created by IWorkspaceStore
    public string RunId { get; set; }                  // Generated by Flow
    public bool Approve { get; set; }                  // From CLI
}
```

### DeliverResponse
```csharp
public class DeliverResponse
{
    public bool Success { get; set; }                  // Operation completed
    public bool ValidationPassed { get; set; }         // Build and run succeeded
    public DeliverResult Result { get; set; }          // All artifacts and paths
}
```

### Processing Steps
1. Load backlog via IBacklogStore
2. Validate item exists
3. Create run directory via IRunArtifactStore
4. Generate ImplementationPlan
5. Generate candidate via FixtureDotNetTemplateGenerator
6. Validate (build + run) via IProcessRunner
7. Compute PatchPreview
8. Write artifacts to runDir
9. Deploy (if approve && validation.Passed) via IAppDeployer
10. Return typed DeliverResponse

---

## Typed Artifacts

### ImplementationPlan
```csharp
public class ImplementationPlan
{
    [JsonPropertyName("run_id")]
    public string RunId { get; set; }
    
    [JsonPropertyName("item_id")]
    public int ItemId { get; set; }
    
    [JsonPropertyName("app_id")]
    public string AppId { get; set; }
    
    [JsonPropertyName("template_id")]
    public string TemplateId { get; set; }             // "fixture_dotnet_console_hello"
    
    [JsonPropertyName("workspace_target_path")]
    public string WorkspaceTargetPath { get; set; }
    
    [JsonPropertyName("actions")]
    public List<string> Actions { get; set; }
}
```

### ValidationCommandResult
```csharp
public class ValidationCommandResult
{
    [JsonPropertyName("name")]
    public string Name { get; set; }
    
    [JsonPropertyName("working_dir")]
    public string WorkingDir { get; set; }
    
    [JsonPropertyName("command_line")]
    public string CommandLine { get; set; }
    
    [JsonPropertyName("exit_code")]
    public int ExitCode { get; set; }
    
    [JsonPropertyName("stdout_file")]
    public string StdoutFile { get; set; }
    
    [JsonPropertyName("stderr_file")]
    public string StderrFile { get; set; }
}
```

### ValidationReport
```csharp
public class ValidationReport
{
    [JsonPropertyName("passed")]
    public bool Passed { get; set; }
    
    [JsonPropertyName("commands")]
    public List<ValidationCommandResult> Commands { get; set; }
}
```

### DeliverPatchPreview
```csharp
public class DeliverPatchPreview
{
    [JsonPropertyName("computed_at_utc")]
    public string ComputedAtUtc { get; set; }
    
    [JsonPropertyName("item_id")]
    public int ItemId { get; set; }
    
    [JsonPropertyName("app_id")]
    public string AppId { get; set; }
    
    [JsonPropertyName("repo_target")]
    public string RepoTarget { get; set; }             // "/apps/{appId}/"
    
    [JsonPropertyName("files")]
    public List<string> Files { get; set; }            // Relative paths
    
    [JsonPropertyName("validation_passed")]
    public bool ValidationPassed { get; set; }
}
```

### PatchApplied
```csharp
public class PatchApplied
{
    [JsonPropertyName("applied_at_utc")]
    public string AppliedAtUtc { get; set; }
    
    [JsonPropertyName("item_id")]
    public int ItemId { get; set; }
    
    [JsonPropertyName("app_id")]
    public string AppId { get; set; }
    
    [JsonPropertyName("run_id")]
    public string RunId { get; set; }
    
    [JsonPropertyName("repo_target")]
    public string RepoTarget { get; set; }
    
    [JsonPropertyName("files_applied")]
    public List<string> FilesApplied { get; set; }
}
```

### DeliverResult
```csharp
public class DeliverResult
{
    public ImplementationPlan Plan { get; set; }
    public ValidationReport Validation { get; set; }
    public DeliverPatchPreview Preview { get; set; }
    public PatchApplied? PatchApplied { get; set; }    // null unless approved
    
    public string WorkspaceRoot { get; set; }
    public string WorkspaceAppRoot { get; set; }
    public string RunDir { get; set; }
}
```

---

## Store Layer Interfaces

### IEpicStore
```csharp
public interface IEpicStore
{
    string ResolveAppId(string workdir, string epicId);
}
```

**Implementation:** EpicStore
- Reads state/epics.yaml
- Throws FileNotFoundException if registry missing
- Throws KeyNotFoundException if epic_id not found

### IWorkspaceStore
```csharp
public interface IWorkspaceStore
{
    string ResetAndCreateWorkspace(string workdir, string appId);
}
```

**Implementation:** WorkspaceStore
- Deletes existing state/workspaces/{appId}/ (determinism)
- Creates state/workspaces/{appId}/apps/{appId}/

### IProcessRunner
```csharp
public interface IProcessRunner
{
    int Run(
        string name,
        string workingDirectory,
        string commandLine,
        string stdoutFile,
        string stderrFile
    );
}
```

**Implementation:** ProcessRunner
- Executes via cmd.exe /c
- Redirects stdout/stderr to files
- Returns exit code

### IAppDeployer
```csharp
public interface IAppDeployer
{
    List<string> Deploy(
        string workdir,
        string workspaceRoot,
        string appId
    );
}
```

**Implementation:** AppDeployer
- Copies from state/workspaces/{appId}/apps/{appId}/ to /apps/{appId}/
- Returns list of deployed files

---

## Preconditions

**Enforced in Flow (Fail-Fast):**

```
1. RepoChecks.ValidateLayout(workdir) → no errors
2. Backlog item with itemId exists
3. item.Status == "ready_for_dev"
4. item.Estimate != null && item.Estimate.StoryPoints > 0
5. !string.IsNullOrEmpty(item.EpicId)
6. IEpicStore.ResolveAppId(workdir, item.EpicId) succeeds

If ANY fails:
   - No artifacts generated
   - No workspace created
   - Appropriate exit code returned
```

---

## Validation Rules

**Validation passes if:**
- dotnet build exits 0
- dotnet run exits 0
- Both outputs captured to files

**Validation fails if:**
- Any command exits non-zero

---

## Approval Rules

**Approval allowed if:**
- Validation.Passed == true
- --approve flag provided

**Approval denied if:**
- Validation.Passed == false
- Returns ValidationFailed (9)

---

## Directory Structure

```
state/
  workspaces/
    {appId}/
      apps/
        {appId}/
          {generated files}      ← Candidate
  runs/
    {runId}_deliver_item-{itemId}/
      implementation-plan.json
      validation.json
      patch.preview.json
      patch.preview.diff
      patch.json                 ← If approved
      summary.md
      build.stdout.log
      build.stderr.log
      run.stdout.log
      run.stderr.log
  backlog.yaml
  epics.yaml
  decisions/
    decision-log.md              ← Appended on approval

/apps/
  {appId}/
    {deployed files}             ← Only if approved
```

---

## Environment Variables

| Variable | Purpose | Default |
|----------|---------|---------|
| `GOVERNOR_APPROVER` | Record approver in decision log | "local" |

---

## Glossary

| Term | Definition |
|------|-----------|
| **runId** | Unique run: `yyyyMMdd_HHmmss_deliver_item-{itemId}` |
| **appId** | App identifier, resolved from epic_id |
| **epicId** | Epic identifier from backlog item |
| **Candidate** | Generated implementation in workspace |
| **Validation** | Building and running candidate |
| **Preview** | Description of what would deploy |
| **Deployment** | Copying candidate from workspace to /apps/ |
| **Approval** | Explicit user decision (--approve flag) |
| **Decision Log** | Immutable record of all approvals |

---

**For implementation details, see [IMPLEMENTATION.md](IMPLEMENTATION.md)**
**For usage guide, see [QUICK_REFERENCE.md](QUICK_REFERENCE.md)**
